/**
 * OfferService
 *
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient, HttpHeaders, HttpParams,
  HttpResponse, HttpEvent, HttpParameterCodec, HttpContext
} from '@angular/common/http';
import { CustomHttpParameterCodec } from '../encoder';
import { Observable } from 'rxjs';

// @ts-ignore
import { ApiErrorDTO } from '../model/apiError.model';
// @ts-ignore
import { OfferCalculationDTO } from '../model/offerCalculation.model';
// @ts-ignore
import { OfferRequestDTO } from '../model/offerRequest.model';
// @ts-ignore
import { OfferResponseDTO } from '../model/offerResponse.model';
// @ts-ignore
import { PersonalDataResponseDTO } from '../model/personalDataResponse.model';
// @ts-ignore
import { PersonalDataValidationDTO } from '../model/personalDataValidation.model';
// @ts-ignore
import { ShortOfferDataDTO } from '../model/shortOfferData.model';
// @ts-ignore
import { TariffDataResponseDTO } from '../model/tariffDataResponse.model';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';
import { BaseService } from '../api.base.service';
import {
  OffersServiceInterface
} from './offers.serviceInterface';


@Injectable({
  providedIn: 'root'
})
export class OffersService extends BaseService implements OffersServiceInterface {

  constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string | string[], @Optional() configuration?: Configuration) {
    super(basePath, configuration);
  }

  /**
   * Calculate an offer
   * ###### Calculates an resource \&#39;Offer\&#39; and returns the offer with calculated data ###### &lt;u&gt;Berechnet eine Ressource \&#39;Angebot\&#39; und liefert es mit dem Berechnungsergebnis zurück.&lt;/u&gt;
   * @param offerCalculationDTO offer to calculate
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public calculateOffer(offerCalculationDTO: OfferCalculationDTO, observe?: 'body', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<OfferResponseDTO>;
  public calculateOffer(offerCalculationDTO: OfferCalculationDTO, observe?: 'response', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpResponse<OfferResponseDTO>>;
  public calculateOffer(offerCalculationDTO: OfferCalculationDTO, observe?: 'events', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpEvent<OfferResponseDTO>>;
  public calculateOffer(offerCalculationDTO: OfferCalculationDTO, observe: any = 'body', reportProgress: boolean = false, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<any> {
    if (offerCalculationDTO === null || offerCalculationDTO === undefined) {
      throw new Error('Required parameter offerCalculationDTO was null or undefined when calling calculateOffer.');
    }

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
      'application/json'
    ]);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;


    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/offers/calculations`;
    return this.httpClient.request<OfferResponseDTO>('post', `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: offerCalculationDTO,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Create an offer
   * ###### Creates a new resource \&#39;Offer\&#39; in the process context. This action takes place when the personal details of the offer are saved. The newly created resource is returned. ###### &lt;u&gt;Erstellt eine neue Ressource \&#39;Angebot\&#39; im Prozesskontext. Diese Aktion findet bei der Speicherung der Personenangaben des Angebotes statt. Die neu erstellte Ressource wird zurückgeliefert.&lt;/u&gt;
   * @param offerRequestDTO new offer
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createOffer(offerRequestDTO: OfferRequestDTO, observe?: 'body', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<OfferResponseDTO>;
  public createOffer(offerRequestDTO: OfferRequestDTO, observe?: 'response', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpResponse<OfferResponseDTO>>;
  public createOffer(offerRequestDTO: OfferRequestDTO, observe?: 'events', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpEvent<OfferResponseDTO>>;
  public createOffer(offerRequestDTO: OfferRequestDTO, observe: any = 'body', reportProgress: boolean = false, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<any> {
    if (offerRequestDTO === null || offerRequestDTO === undefined) {
      throw new Error('Required parameter offerRequestDTO was null or undefined when calling createOffer.');
    }

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
      'application/json'
    ]);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;


    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/offers`;
    return this.httpClient.request<OfferResponseDTO>('post', `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: offerRequestDTO,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Create an offer PDF document
   * ###### Creates and returns a PDF document \&#39;short offer\&#39; on an existing resource \&#39;Offer\&#39; ###### &lt;u&gt;Erstellt ein PDF Dokument \&#39;Kurzangebot\&#39; an einer bestehenden Ressource \&#39;Angebot\&#39; und liefert es zurück&lt;/u&gt;
   * @param offerId offer ID
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createOfferDocument(offerId: number, observe?: 'body', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/pdf' | 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<Blob>;
  public createOfferDocument(offerId: number, observe?: 'response', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/pdf' | 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpResponse<Blob>>;
  public createOfferDocument(offerId: number, observe?: 'events', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/pdf' | 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpEvent<Blob>>;
  public createOfferDocument(offerId: number, observe: any = 'body', reportProgress: boolean = false, options?: {
    httpHeaderAccept?: 'application/pdf' | 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<any> {
    if (offerId === null || offerId === undefined) {
      throw new Error('Required parameter offerId was null or undefined when calling createOfferDocument.');
    }

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
      'application/pdf',
      'application/json'
    ]);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;


    let localVarPath = `/offers/${this.configuration.encodeParam({
      name: 'offerId',
      value: offerId,
      in: 'path',
      style: 'simple',
      explode: false,
      dataType: 'number',
      dataFormat: 'int64'
    })}/documents`;
    return this.httpClient.request('post', `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: 'blob',
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Provides default personal data
   * ###### Provides default values for the personal data based on product type ###### &lt;u&gt;Stellt Standardwerte für die Personendaten basierend auf dem Produkttyp bereit&lt;/u&gt;
   * @param productType product type
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getDefaultPersonalData(productType: string, observe?: 'body', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<PersonalDataResponseDTO>;
  public getDefaultPersonalData(productType: string, observe?: 'response', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpResponse<PersonalDataResponseDTO>>;
  public getDefaultPersonalData(productType: string, observe?: 'events', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpEvent<PersonalDataResponseDTO>>;
  public getDefaultPersonalData(productType: string, observe: any = 'body', reportProgress: boolean = false, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<any> {
    if (productType === null || productType === undefined) {
      throw new Error('Required parameter productType was null or undefined when calling getDefaultPersonalData.');
    }

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
      'application/json'
    ]);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;


    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/offers/personalData/${this.configuration.encodeParam({
      name: 'productType',
      value: productType,
      in: 'path',
      style: 'simple',
      explode: false,
      dataType: 'string',
      dataFormat: undefined
    })}`;
    return this.httpClient.request<PersonalDataResponseDTO>('get', `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Provides default tariff data
   * ###### Provides default values for the tariff data based on product type ###### &lt;u&gt;Stellt Standardwerte für die Tariffdaten basierend auf dem Produkttyp bereit&lt;/u&gt;
   * @param productType product type
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getDefaultTariffData(productType: string, observe?: 'body', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<TariffDataResponseDTO>;
  public getDefaultTariffData(productType: string, observe?: 'response', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpResponse<TariffDataResponseDTO>>;
  public getDefaultTariffData(productType: string, observe?: 'events', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpEvent<TariffDataResponseDTO>>;
  public getDefaultTariffData(productType: string, observe: any = 'body', reportProgress: boolean = false, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<any> {
    if (productType === null || productType === undefined) {
      throw new Error('Required parameter productType was null or undefined when calling getDefaultTariffData.');
    }

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
      'application/json'
    ]);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;


    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/offers/tariffData/${this.configuration.encodeParam({
      name: 'productType',
      value: productType,
      in: 'path',
      style: 'simple',
      explode: false,
      dataType: 'string',
      dataFormat: undefined
    })}`;
    return this.httpClient.request<TariffDataResponseDTO>('get', `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Find an offer
   * ###### Provides the complete resource \&#39;Offer\&#39; with all associated data such as personal and tariff details ###### &lt;u&gt;Liefert die vollständige Ressource \&#39;Angebot\&#39; mit allen damit verbundenen Daten wie persönliche und tarifflichen Angaben&lt;/u&gt;
   * @param offerId ID of offer to return
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getOffer(offerId: number, observe?: 'body', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<OfferResponseDTO>;
  public getOffer(offerId: number, observe?: 'response', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpResponse<OfferResponseDTO>>;
  public getOffer(offerId: number, observe?: 'events', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpEvent<OfferResponseDTO>>;
  public getOffer(offerId: number, observe: any = 'body', reportProgress: boolean = false, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<any> {
    if (offerId === null || offerId === undefined) {
      throw new Error('Required parameter offerId was null or undefined when calling getOffer.');
    }

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
      'application/json'
    ]);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;


    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/offers/${this.configuration.encodeParam({
      name: 'offerId',
      value: offerId,
      in: 'path',
      style: 'simple',
      explode: false,
      dataType: 'number',
      dataFormat: 'int64'
    })}`;
    return this.httpClient.request<OfferResponseDTO>('get', `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Update an offer
   * ###### Updates an offer ###### &lt;u&gt;Aktualisiert ein Angebot&lt;/u&gt;
   * @param offerId ID of offer to update
   * @param offerRequestDTO offer to update
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateOffer(offerId: number, offerRequestDTO: OfferRequestDTO, observe?: 'body', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<OfferResponseDTO>;
  public updateOffer(offerId: number, offerRequestDTO: OfferRequestDTO, observe?: 'response', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpResponse<OfferResponseDTO>>;
  public updateOffer(offerId: number, offerRequestDTO: OfferRequestDTO, observe?: 'events', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpEvent<OfferResponseDTO>>;
  public updateOffer(offerId: number, offerRequestDTO: OfferRequestDTO, observe: any = 'body', reportProgress: boolean = false, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<any> {
    if (offerId === null || offerId === undefined) {
      throw new Error('Required parameter offerId was null or undefined when calling updateOffer.');
    }
    if (offerRequestDTO === null || offerRequestDTO === undefined) {
      throw new Error('Required parameter offerRequestDTO was null or undefined when calling updateOffer.');
    }

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
      'application/json'
    ]);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;


    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/offers/${this.configuration.encodeParam({
      name: 'offerId',
      value: offerId,
      in: 'path',
      style: 'simple',
      explode: false,
      dataType: 'number',
      dataFormat: 'int64'
    })}`;
    return this.httpClient.request<OfferResponseDTO>('put', `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: offerRequestDTO,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Validates personal data
   * ###### Validates personal data in the \&#39;Occupational disability\&#39; tariff ###### &lt;u&gt;Validiert die Personendaten im Tarif \&#39;Berufsunfähigkeit\&#39;&lt;/u&gt;
   * @param personalDataValidationDTO offer
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public validatePersonalData(personalDataValidationDTO: PersonalDataValidationDTO, observe?: 'body', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<PersonalDataResponseDTO>;
  public validatePersonalData(personalDataValidationDTO: PersonalDataValidationDTO, observe?: 'response', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpResponse<PersonalDataResponseDTO>>;
  public validatePersonalData(personalDataValidationDTO: PersonalDataValidationDTO, observe?: 'events', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpEvent<PersonalDataResponseDTO>>;
  public validatePersonalData(personalDataValidationDTO: PersonalDataValidationDTO, observe: any = 'body', reportProgress: boolean = false, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<any> {
    if (personalDataValidationDTO === null || personalDataValidationDTO === undefined) {
      throw new Error('Required parameter personalDataValidationDTO was null or undefined when calling validatePersonalData.');
    }

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
      'application/json'
    ]);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;


    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/offers/personalData/validations`;
    return this.httpClient.request<PersonalDataResponseDTO>('post', `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: personalDataValidationDTO,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress
      }
    );
  }

  /**
   * Validates short offer data
   * ###### Validates short offer data ###### &lt;u&gt;Validiert die Kurzangebotangaben&lt;/u&gt;
   * @param shortOfferDataDTO short offer
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public validateShortOfferData(shortOfferDataDTO: ShortOfferDataDTO, observe?: 'body', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<ShortOfferDataDTO>;
  public validateShortOfferData(shortOfferDataDTO: ShortOfferDataDTO, observe?: 'response', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpResponse<ShortOfferDataDTO>>;
  public validateShortOfferData(shortOfferDataDTO: ShortOfferDataDTO, observe?: 'events', reportProgress?: boolean, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<HttpEvent<ShortOfferDataDTO>>;
  public validateShortOfferData(shortOfferDataDTO: ShortOfferDataDTO, observe: any = 'body', reportProgress: boolean = false, options?: {
    httpHeaderAccept?: 'application/json',
    context?: HttpContext,
    transferCache?: boolean
  }): Observable<any> {
    if (shortOfferDataDTO === null || shortOfferDataDTO === undefined) {
      throw new Error('Required parameter shortOfferDataDTO was null or undefined when calling validateShortOfferData.');
    }

    let localVarHeaders = this.defaultHeaders;

    const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
      'application/json'
    ]);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;


    // to determine the Content-Type header
    const consumes: string[] = [
      'application/json'
    ];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/offers/shortOfferData/validations`;
    return this.httpClient.request<ShortOfferDataDTO>('post', `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: shortOfferDataDTO,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress
      }
    );
  }

}
